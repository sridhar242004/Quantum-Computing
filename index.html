<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Algorithms</title>
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            background: linear-gradient(135deg, #2b2d42, #8d99ae);
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #edf2f4;
            animation: fadeIn 2s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .container {
            background-color: #1e1d1d;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            text-align: center;
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            transition: transform 0.3s, box-shadow 0.3s;
            animation: slideIn 1s ease-out;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        @keyframes slideIn {
            from { transform: translateY(-100px); }
            to { transform: translateY(0); }
        }
        
        .container:hover {
            transform: translateY(-10px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            animation: glow 1.5s infinite alternate;
        }
        
        @keyframes glow {
            from { text-shadow: 2px 2px 10px #ef233c; }
            to { text-shadow: 2px 2px 20px #ef233c; }
        }
        
        label, select {
            margin: 10px;
            font-size: 1.2rem;
            display: inline-block;
            transition: color 0.3s;
        }
        
        select {
            padding: 10px;
            border-radius: 5px;
            border: 2px solid #8d99ae;
            background-color: #edf2f4;
            color: #2b2d42;
            cursor: pointer;
            transition: border-color 0.3s;
        }
        
        select:hover {
            border-color: #2b2d42;
        }
        
        #algorithm-description {
            margin: 20px 0;
            font-size: 1rem;
            text-align: left;
            background-color: #8d99ae;
            padding: 15px;
            border-radius: 10px;
            color: #2b2d42;
            transition: background-color 0.3s, color 0.3s;
            animation: fadeInUp 1s ease-out;
        }
        
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        #algorithm-description:hover {
            background-color: #2b2d42;
            color: #edf2f4;
        }
        
        #quantum-circuit {
            margin: 20px 0;
            border: 2px solid #8d99ae;
            padding: 15px;
            background-color: #edf2f4;
            text-align: left;
            white-space: pre;
            font-family: 'Courier New', monospace;
            color: #2b2d42;
            border-radius: 10px;
            transition: border-color 0.3s, background-color 0.3s;
            animation: fadeInRight 1s ease-out;
        }
        
        @keyframes fadeInRight {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        #quantum-circuit:hover {
            border-color: #2b2d42;
            background-color: #d90429;
            color: #edf2f4;
        }
        
        button {
            padding: 12px 25px;
            font-size: 1.2rem;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background-color: #d90429;
            color: #edf2f4;
            transition: background-color 0.3s, transform 0.3s;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.05); }
        }
        
        button:hover {
            background-color: #ef233c;
            transform: scale(1.1);
        }
        
        button:active {
            background-color: #ba1b1d;
        }
        
        #result {
            margin-top: 20px;
            font-size: 1.2rem;
            font-weight: bold;
            color: #d90429;
            background-color: #8d99ae;
            padding: 15px;
            border-radius: 10px;
            transition: background-color 0.3s, color 0.3s;
            animation: fadeInLeft 1s ease-out;
        }
        
        @keyframes fadeInLeft {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        #result:hover {
            background-color: #2b2d42;
            color: #edf2f4;
        }
        
        @media (max-width: 768px) {
            .container {
                width: 100%;
                height: 100%;
                border-radius: 0;
            }
        
            h1 {
                font-size: 2rem;
            }
        }
        
        /* Additional Effects */
        
        /* Glow Effect */
        button {
            box-shadow: 0 0 20px rgba(217, 4, 41, 0.6);
        }
        
        button:hover {
            box-shadow: 0 0 30px rgba(239, 35, 60, 0.8);
        }
        
        /* Container Slide Up */
        @keyframes slideUp {
            from { transform: translateY(50px); }
            to { transform: translateY(0); }
        }
        
        .container {
            animation: slideUp 0.5s ease-out;
        }
        
        /* Shake Effect on Result Hover */
        #result:hover {
            animation: shake 0.5s;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
        }
        
        /* Bouncing Select Options */
        select {
            animation: bounce 2s infinite;
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        /* Highlight Effect for Description */
        #algorithm-description:hover {
            animation: highlight 0.5s ease-in-out;
        }
        
        @keyframes highlight {
            0%, 100% { background-color: #2b2d42; color: #edf2f4; }
            50% { background-color: #edf2f4; color: #2b2d42; }
        }
        
        /* Fade-in Effect for Quantum Circuit */
        #quantum-circuit {
            animation: fadeIn 2s ease-in-out;
        }
        
        /* Glowing Text in Result */
        @keyframes glowText {
            from { text-shadow: 0 0 10px #d90429; }
            to { text-shadow: 0 0 20px #d90429; }
        }
        
        #result {
            animation: glowText 1.5s infinite alternate;
        }
        
        /* Rotate Effect on Button Hover */
        button:hover {
            transform: scale(1.1) rotate(3deg);
        }
        
        /* Gradient Background for Select Options */
        select {
            background: linear-gradient(135deg, #edf2f4, #2b2d42);
        }
        
        /* Expand Effect on Container Hover */
        .container:hover {
            transform: translateY(-10px) scale(1.05);
        }
        
        /* Pulse Effect on Quantum Circuit */
        @keyframes pulseCircuit {
            from { box-shadow: 0 0 10px rgba(217, 4, 41, 0.6); }
            to { box-shadow: 0 0 20px rgba(239, 35, 60, 0.8); }
        }
        
        #quantum-circuit {
            animation: pulseCircuit 1.5s infinite;
        }
        
    </style>
</head>
<body>
    <div class="container">
        <h1>Quantum Algorithm Simulator</h1>
        <label for="algorithm-select">Choose an algorithm:</label>
        <select id="algorithm-select">
            <option value="grover">Grover's Algorithm</option>
            <option value="shor">Shor's Algorithm</option>
            <option value="dj">Deutsch-Jozsa Algorithm</option>
            <option value="bv">Bernstein-Vazirani Algorithm</option>
            <option value="qft">Quantum Fourier Transform</option>
            <option value="qpe">Quantum Phase Estimation</option>
            <option value="hhl">HHL Algorithm</option>
            <option value="qkd">Quantum Key Distribution</option>
            <option value="qwalk">Quantum Walk</option>
            <option value="qsvt">Quantum Singular Value Transformation</option>
            <option value="qae">Quantum Amplitude Estimation</option>
            <option value="qml">Quantum Machine Learning</option>
            <option value="vqe">Variational Quantum Eigensolver</option>
            <option value="qaoa">Quantum Approximate Optimization Algorithm</option>
            <option value="qnn">Quantum Neural Networks</option>
            <option value="qsm">Quantum State Tomography</option>
            <option value="qswitch">Quantum Switch</option>
            <option value="qcir">Quantum Circuit Learning</option>
            <option value="qsamp">Quantum Sampling</option>
            <option value="qsimp">Quantum Simulated Annealing</option>
            <option value="qgrad">Quantum Gradient Descent</option>
            <option value="qsolv">Quantum Solvers for Differential Equations</option>
            <!-- Add more algorithms as needed -->
        </select>
        <div id="algorithm-description">Description will be displayed here.</div>
        <div id="quantum-circuit">Quantum circuit will be displayed here.</div>
        <button id="run-algorithm">Run Algorithm</button>
        <div id="result">Result will be displayed here.</div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const algorithmDescriptions = {
                'grover': 'Grover\'s algorithm is a quantum search algorithm that finds a target element in an unsorted database with quadratic speedup over classical algorithms.',
                'shor': 'Shor\'s algorithm is a quantum algorithm for integer factorization, which underpins the security of many cryptographic systems. It can efficiently factorize large integers and break RSA encryption.',
                'dj': 'The Deutsch-Jozsa algorithm is a quantum algorithm that solves the Deutsch problem with a single query, demonstrating quantum parallelism.',
                'bv': 'The Bernstein-Vazirani algorithm determines a hidden string with a single query, showcasing the efficiency of quantum algorithms over classical counterparts.',
                'qft': 'Quantum Fourier Transform (QFT) is the quantum analogue of the discrete Fourier transform and is a key component in many quantum algorithms.',
                'qpe': 'Quantum Phase Estimation (QPE) algorithm estimates the phase (or eigenvalue) of an eigenvector of a unitary operator, fundamental in quantum algorithms like Shor\'s.',
                'hhl': 'Harrow-Hassidim-Lloyd (HHL) algorithm solves linear systems of equations exponentially faster than classical algorithms under certain conditions.',
                'qkd': 'Quantum Key Distribution (QKD) uses quantum mechanics to securely distribute cryptographic keys, guaranteeing security based on physical laws.',
                'qwalk': 'Quantum Walks are quantum analogues of classical random walks, used in search algorithms and studying quantum system dynamics.',
                'qsvt': 'Quantum Singular Value Transformation (QSVT) provides a way to implement any polynomial transformation of the singular values of a matrix.',
                'qae': 'Quantum Amplitude Estimation (QAE) improves the precision of probability estimations in quantum algorithms, essential for applications like quantum finance.',
                'qml': 'Quantum Machine Learning (QML) applies quantum computing to machine learning, offering potential speedups for various learning tasks.',
                'vqe': 'Variational Quantum Eigensolver (VQE) is a hybrid quantum-classical algorithm for finding the ground state energy of a quantum system.',
                'qaoa': 'Quantum Approximate Optimization Algorithm (QAOA) approximates solutions to combinatorial optimization problems using quantum mechanics.',
                'qnn': 'Quantum Neural Networks (QNN) integrate quantum computing with neural networks, aiming to enhance machine learning capabilities.',
                'qsm': 'Quantum State Tomography reconstructs the state of a quantum system from measurement data, crucial for verifying quantum devices.',
                'qswitch': 'Quantum Switch allows for superpositions of different causal orders, offering new computational and communication capabilities.',
                'qcir': 'Quantum Circuit Learning utilizes quantum circuits to model and learn from data, potentially outperforming classical models.',
                'qsamp': 'Quantum Sampling algorithms leverage quantum mechanics to sample from complex probability distributions more efficiently than classical algorithms.',
                'qsimp': 'Quantum Simulated Annealing finds global minima of functions by simulating quantum tunneling, providing speedups over classical simulated annealing.',
                'qgrad': 'Quantum Gradient Descent leverages quantum computing to perform gradient-based optimization, promising speedups for machine learning and optimization tasks.',
                'qsolv': 'Quantum Solvers for Differential Equations solve differential equations using quantum computers, applicable in fields like quantum chemistry and physics.'
                // Add more algorithm descriptions as needed
            };
        
            const algorithmSelect = document.getElementById('algorithm-select');
            const descriptionDiv = document.getElementById('algorithm-description');
            const resultDiv = document.getElementById('result');
            const circuitDiv = document.getElementById('quantum-circuit');
        
            algorithmSelect.addEventListener('change', () => {
                const selectedAlgorithm = algorithmSelect.value;
                descriptionDiv.innerText = algorithmDescriptions[selectedAlgorithm] || 'Description not available.';
            });
        
            document.getElementById('run-algorithm').addEventListener('click', () => {
                const algorithm = algorithmSelect.value;
                resultDiv.innerText = 'Running...';
                circuitDiv.innerText = '';
        
                let result;
                let circuit;
        
                try {
                    if (algorithm === 'grover') {
                        [result, circuit] = runGroverAlgorithm();
                    } else if (algorithm === 'shor') {
                        [result, circuit] = runShorAlgorithm();
                    } else if (algorithm === 'dj') {
                        [result, circuit] = runDJAlgorithm();
                    } else if (algorithm === 'bv') {
                        [result, circuit] = runBVAlgorithm();
                    } else if (algorithm === 'qft') {
                        [result, circuit] = runQFTAlgorithm();
                    } else if (algorithm === 'qpe') {
                        [result, circuit] = runQPEAlgorithm();
                    } else if (algorithm === 'hhl') {
                        [result, circuit] = runHHLAlgorithm();
                    } else if (algorithm === 'qkd') {
                        [result, circuit] = runQKDAlgorithm();
                    } else if (algorithm === 'qwalk') {
                        [result, circuit] = runQWalkAlgorithm();
                    } else if (algorithm === 'qsvt') {
                        [result, circuit] = runQSVTAlgorithm();
                    } else if (algorithm === 'qae') {
                        [result, circuit] = runQAEAlgorithm();
                    } else if (algorithm === 'qml') {
                        [result, circuit] = runQMLAlgorithm();
                    } else if (algorithm === 'vqe') {
                        [result, circuit] = runVQEAlgorithm();
                    } else if (algorithm === 'qaoa') {
                        [result, circuit] = runQAOAAlgorithm();
                    } else if (algorithm === 'qnn') {
                        [result, circuit] = runQNNAlgorithm();
                    } else if (algorithm === 'qsm') {
                        [result, circuit] = runQSMAlgorithm();
                    } else if (algorithm === 'qswitch') {
                        [result, circuit] = runQSwitchAlgorithm();
                    } else if (algorithm === 'qcir') {
                        [result, circuit] = runQCIRAlgorithm();
                    } else if (algorithm === 'qsamp') {
                        [result, circuit] = runQSAMPAlgorithm();
                    } else if (algorithm === 'qsimp') {
                        [result, circuit] = runQSIMPAlgorithm();
                    } else if (algorithm === 'qgrad') {
                        [result, circuit] = runQGradAlgorithm();
                    } else if (algorithm === 'qsolv') {
                        [result, circuit] = runQSOLVAlgorithm();
                    } else {
                        throw new Error("Algorithm not implemented.");
                    }
        
                    resultDiv.innerText = `Result: ${JSON.stringify(result)}`;
                    circuitDiv.innerText = circuit.join('\n');
                } catch (error) {
                    resultDiv.innerText = `Error: ${error.message}`;
                }
            });
        
            function runGroverAlgorithm() {
                const circuit = [
                    'H q[0]',
                    'H q[1]',
                    'CZ q[0], q[1]',
                    'H q[0]',
                    'H q[1]',
                    'Measure q[0]',
                    'Measure q[1]'
                ];
                const result = { '00': 512, '11': 512 }; // Simplified result
                return [result, circuit];
            }
        
            function runShorAlgorithm() {
                const circuit = [
                    'H q[0]',
                    'H q[1]',
                    'H q[2]',
                    'CX q[0], q[1]',
                    'CX q[1], q[2]',
                    'H q[0]',
                    'H q[1]',
                    'H q[2]',
                    'Measure q[0]',
                    'Measure q[1]',
                    'Measure q[2]'
                ];
                const result = { '000': 341, '011': 341, '101': 341 }; // Simplified result
                return [result, circuit];
            }
        
            function runDJAlgorithm() {
                const circuit = [
                    'H q[0]',
                    'H q[1]',
                    'H q[2]',
                    'Measure q[0]',
                    'Measure q[1]',
                    'Measure q[2]'
                ];
                const result = { '000': 500, '111': 500 }; // Simplified result
                return [result, circuit];
            }
        
            function runBVAlgorithm() {
                const circuit = [
                    'H q[0]',
                    'H q[1]',
                    'H q[2]',
                    'Measure q[0]',
                    'Measure q[1]',
                    'Measure q[2]'
                ];
                const result = { '101': 1000 }; // Simplified result
                return [result, circuit];
            }
        
            function runQFTAlgorithm() {
                const circuit = [
                    'H q[0]',
                    'H q[1]',
                    'H q[2]',
                    'Measure q[0]',
                    'Measure q[1]',
                    'Measure q[2]'
                ];
                const result = { '000': 512, '111': 512 }; // Simplified result
                return [result, circuit];
            }
        
            function runQPEAlgorithm() {
                const circuit = [
                    'H q[0]',
                    'H q[1]',
                    'H q[2]',
                    'CX q[0], q[1]',
                    'CX q[1], q[2]',
                    'Measure q[0]',
                    'Measure q[1]',
                    'Measure q[2]'
                ];
                const result = { '001': 600, '110': 400 }; // Simplified result
                return [result, circuit];
            }
        
            function runHHLAlgorithm() {
                const circuit = [
                    'H q[0]',
                    'H q[1]',
                    'H q[2]',
                    'CX q[0], q[1]',
                    'CX q[1], q[2]',
                    'Measure q[0]',
                    'Measure q[1]',
                    'Measure q[2]'
                ];
                const result = { '010': 700, '101': 300 }; // Simplified result
                return [result, circuit];
            }
        
            function runQKDAlgorithm() {
                const circuit = [
                    'H q[0]',
                    'H q[1]',
                    'Measure q[0]',
                    'Measure q[1]'
                ];
                const result = { '00': 512, '11': 512 }; // Simplified result
                return [result, circuit];
            }
        
            function runQWalkAlgorithm() {
                const circuit = [
                    'H q[0]',
                    'H q[1]',
                    'H q[2]',
                    'Measure q[0]',
                    'Measure q[1]',
                    'Measure q[2]'
                ];
                const result = { '010': 800, '101': 200 }; // Simplified result
                return [result, circuit];
            }
        
            function runQSVTAlgorithm() {
                const circuit = [
                    'H q[0]',
                    'H q[1]',
                    'H q[2]',
                    'Measure q[0]',
                    'Measure q[1]',
                    'Measure q[2]'
                ];
                const result = { '011': 900, '100': 100 }; // Simplified result
                return [result, circuit];
            }
        
            function runQAEAlgorithm() {
                const circuit = [
                    'H q[0]',
                    'H q[1]',
                    'H q[2]',
                    'Measure q[0]',
                    'Measure q[1]',
                    'Measure q[2]'
                ];
                const result = { '001': 600, '110': 400 }; // Simplified result
                return [result, circuit];
            }
        
            function runQMLAlgorithm() {
                const circuit = [
                    'H q[0]',
                    'H q[1]',
                    'H q[2]',
                    'Measure q[0]',
                    'Measure q[1]',
                    'Measure q[2]'
                ];
                const result = { '000': 700, '111': 300 }; // Simplified result
                return [result, circuit];
            }
        
            function runVQEAlgorithm() {
                const circuit = [
                    'H q[0]',
                    'H q[1]',
                    'Measure q[0]',
                    'Measure q[1]'
                ];
                const result = { '01': 500, '10': 500 }; // Simplified result
                return [result, circuit];
            }
        
            function runQAOAAlgorithm() {
                const circuit = [
                    'H q[0]',
                    'H q[1]',
                    'Measure q[0]',
                    'Measure q[1]'
                ];
                const result = { '00': 512, '11': 512 }; // Simplified result
                return [result, circuit];
            }
        
            function runQNNAlgorithm() {
                const circuit = [
                    'H q[0]',
                    'H q[1]',
                    'Measure q[0]',
                    'Measure q[1]'
                ];
                const result = { '00': 512, '11': 512 }; // Simplified result
                return [result, circuit];
            }
        
            function runQSMAlgorithm() {
                const circuit = [
                    'H q[0]',
                    'H q[1]',
                    'Measure q[0]',
                    'Measure q[1]'
                ];
                const result = { '01': 512, '10': 512 }; // Simplified result
                return [result, circuit];
            }
        
            function runQSwitchAlgorithm() {
                const circuit = [
                    'H q[0]',
                    'H q[1]',
                    'Measure q[0]',
                    'Measure q[1]'
                ];
                const result = { '10': 512, '01': 512 }; // Simplified result
                return [result, circuit];
            }
        
            function runQCIRAlgorithm() {
                const circuit = [
                    'H q[0]',
                    'H q[1]',
                    'Measure q[0]',
                    'Measure q[1]'
                ];
                const result = { '01': 512, '10': 512 }; // Simplified result
                return [result, circuit];
            }
        
            function runQSAMPAlgorithm() {
                const circuit = [
                    'H q[0]',
                    'H q[1]',
                    'Measure q[0]',
                    'Measure q[1]'
                ];
                const result = { '10': 512, '01': 512 }; // Simplified result
                return [result, circuit];
            }
        
            function runQSIMPAlgorithm() {
                const circuit = [
                    'H q[0]',
                    'H q[1]',
                    'Measure q[0]',
                    'Measure q[1]'
                ];
                const result = { '00': 512, '11': 512 }; // Simplified result
                return [result, circuit];
            }
        
            function runQGradAlgorithm() {
                const circuit = [
                    'H q[0]',
                    'H q[1]',
                    'Measure q[0]',
                    'Measure q[1]'
                ];
                const result = { '11': 512, '00': 512 }; // Simplified result
                return [result, circuit];
            }
        
            function runQSOLVAlgorithm() {
                const circuit = [
                    'H q[0]',
                    'H q[1]',
                    'Measure q[0]',
                    'Measure q[1]'
                ];
                const result = { '10': 512, '01': 512 }; // Simplified result
                return [result, circuit];
            }
        
            // Trigger initial description load
            algorithmSelect.dispatchEvent(new Event('change'));
        });
        
    </script>
</body>
</html>
